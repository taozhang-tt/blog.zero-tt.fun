---
title: 08 | 事务到底是隔离的还是不隔离的
date: 2021-03-10
disqus: true # 是否开启disqus评论
categories:
  - "Mysql"
tags:
  - "Mysql实战45讲"
---

<!--more-->

# 08 | 事务到底是隔离的还是不隔离的

![20210203091109](http://pic.zero-tt.fun/note/20210203091109.png)

## 事务的启动时机是什么时候
* 不同的启动方式，事务的启动时机不同；
* begin/start transaction 都可以开启一个事务，但这并不是事务的起点，一直到执行第一个操作 InnoDB 表的语句，事务才真正开始；
* 如果想立马开启事务，可以使用 start transaction with consistent snapshot

## 视图的创建时机
* 通过begin/start transaction启动事务，一致性视图在第一个读快照语句时生成；
* 通过tart transaction with consistent snapshot启动的事务，视图立即被创建

## mysql里两种视图的概念
* 一个是 view，它是通过查询语句定义的虚拟表，查询方法和表一样
* 一个是InnoDB实现MVCC时用到的“一致性读”视图，用于支持 RC 和 RR

## InnoDB是如何秒级创建快照的
* 严格来说不是快照，实质上是保存了数据的多个版本，同时保存了各个版本之间的关系（undo log），由新的版本可以推算得出旧版本；
* 具体表现为数据表中的每行记录都可能存在多个版本，每个版本都对应着一个 transaction id，记为 row trx_id，这个 transaction id 是系统为每个事务分配的唯一id，它按照事务启动的顺序严格递增

## 快照在mvcc里是如何工作的
* 事务启动的时候会被分配一个 trx_id，当该事务获取某行数据时，会对比这行数据的当前trx_id，
    * 发现比自己大，那说明这个是被自己之后的事务更新的数据，不认，需要继续查找上一个版本；
    * 如果和自己的 trx_id 一样，说明是自己所做的更改，要认
    * 如果比自己的 trx_id 小，说明是在自己启动以前这个数据就被更新掉了，也要认；

## 一致性视图里更新逻辑是怎样的
更新数据都是**先读后写**，并且这个读都是**当前读**

## 读提交和可重复复的逻辑区别是什么

* 可重复读隔离级别下，事务开启以后创建一个一致性读视图，整个事务过过程中读查询都使用这个视图
* 读提交隔离级别下，每个语句执行前都会重新计算出一个视图